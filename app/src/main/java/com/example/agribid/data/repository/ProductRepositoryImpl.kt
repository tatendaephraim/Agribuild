package com.example.agribid.data.repository

import android.util.Log
import com.example.agribid.core.di.ApplicationScope // **Import the annotation from the correct package**
import com.example.agribid.data.local.db.ProductDao
import com.example.agribid.data.mapper.toDomainModel
import com.example.agribid.data.mapper.toDto
import com.example.agribid.data.mapper.toEntity
import com.example.agribid.data.remote.ProductRemoteDataSource
import com.example.agribid.domain.model.ProductListing
import com.example.agribid.domain.repository.ProductRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ProductRepositoryImpl @Inject constructor(
    private val remoteDataSource: ProductRemoteDataSource,
    private val localDao: ProductDao,
    @ApplicationScope private val externalScope: CoroutineScope // Inject the qualified scope
) : ProductRepository {

    /**
     * Returns a Flow from the local database (Single Source of Truth).
     * Triggers a background refresh from the network.
     */
    override fun getProductListings(
        country: String?,
        province: String?
    ): Flow<List<ProductListing>> {
        val cacheKey = country ?: "all"
        Log.d("ProductRepo", "Getting listings flow for key: $cacheKey")

        // Launch refresh in the background using the injected scope
        externalScope.launch {
            refreshProductListings(country, province)
        }

        // Return the Flow from the local database
        val dbFlow = if (cacheKey == "all") {
            localDao.getAllListings()
        } else {
            localDao.getListingsByCountry(cacheKey)
        }

        return dbFlow.map { entityList ->
            // Map database entities to domain models
            entityList.map { entity -> entity.toDomainModel() }
        }.catch { e ->
            Log.e("ProductRepo", "Error reading products from DB for key '$cacheKey'", e)
            emit(emptyList()) // Emit empty list on DB error
        }.flowOn(Dispatchers.IO) // Ensure DB operations run on IO thread
    }

    /**
     * Fetches fresh data from the network and updates the local database.
     * Should be launched in a background scope.
     */
    private suspend fun refreshProductListings(country: String?, province: String?) {
        val cacheKey = country ?: "all"
        Log.d("ProductRepo", "Attempting refresh for key: $cacheKey")
        try {
            // Fetch from remote - Use flowOn for dispatcher, catch for errors
            remoteDataSource.getProductListings(country, province)
                .flowOn(Dispatchers.IO) // Ensure network call is on IO thread
                .catch { e -> Log.e("ProductRepo", "Remote fetch failed for key '$cacheKey'", e); emit(emptyList()) } // Catch errors within the flow
                .collect { remoteListings ->
                    Log.d("ProductRepo", "Got ${remoteListings.size} remote listings for key: $cacheKey")

                    // Map DTOs to Entities, passing the cache key
                    val entities = remoteListings.map { dto -> dto.toEntity(cacheKey) }

                    // Update local DB (Room typically handles its own dispatcher, but explicit IO is safe)
                    withContext(Dispatchers.IO) {
                        if (cacheKey == "all") {
                            localDao.deleteAll()
                        } else {
                            localDao.deleteByCountry(cacheKey)
                        }
                        localDao.insertAll(entities)
                    }
                    Log.d("ProductRepo", "Cache updated for key: $cacheKey")
                }
        } catch (e: Exception) {
            // Catch any unexpected errors outside the flow collection
            Log.e("ProductRepo", "Unhandled exception during refresh for key '$cacheKey'", e)
        }
    }


    override suspend fun createListing(listing: ProductListing): Result<String> {
        // Ensure productId is blank if we want Firestore to generate it
        val dtoToSend = listing.toDto().copy(
            productId = if (listing.productId.isBlank()) "" else listing.productId // Send blank ID for generation
        )

        // Attempt remote creation first
        val remoteResult = remoteDataSource.createListing(dtoToSend)

        // If remote creation is successful, update local cache
        if (remoteResult.isSuccess) {
            // Get the ID (either provided or generated by Firestore)
            val generatedId = remoteResult.getOrNull() ?: dtoToSend.productId // Use returned ID or original if not blank
            if (generatedId.isNotBlank()) {
                // Create the DTO with the confirmed ID for caching
                val dtoToCache = dtoToSend.copy(productId = generatedId)
                try {
                    // Determine cache key for insertion
                    val cacheKey = listing.country ?: "all"
                    withContext(Dispatchers.IO) {
                        // Map DTO to Entity and insert into DB
                        localDao.insertAll(listOf(dtoToCache.toEntity(cacheKey)))
                    }
                    Log.d("ProductRepo", "Cached newly created listing: $generatedId")
                } catch (e: Exception) {
                    Log.e("ProductRepo", "Failed to cache created listing locally (ID: $generatedId)", e)
                    // Don't fail the overall operation if only caching fails
                }
            } else {
                Log.w("ProductRepo", "Remote creation succeeded but no ID returned/found for caching.")
            }
        } else {
            Log.e("ProductRepo", "Remote listing creation failed.", remoteResult.exceptionOrNull())
        }
        return remoteResult // Return the result of the remote operation
    }

    override suspend fun getListingById(id: String): ProductListing? {
        // Simple remote fetch. Could add caching later.
        // Remember to handle potential exceptions if remoteDataSource throws
        return try {
            remoteDataSource.getListingById(id)?.toDomainModel()
        } catch (e: Exception) {
            Log.e("ProductRepo", "Error fetching listing by ID $id", e)
            null
        }
    }
}

